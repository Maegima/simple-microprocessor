// Quartus Prime Verilog Template
// Simple Dual Port RAM with separate read/write addresses and
// single read/write clock

module memoriaDePrograma(data, saida, write_addr, read_addr, EscMen, clk);
parameter DATA_WIDTH=32, ADDR_WIDTH=8;


input [(DATA_WIDTH-1):0] data;
input [(ADDR_WIDTH-1):0] read_addr, write_addr;
input EscMen, clk;
output reg [(DATA_WIDTH-1):0] saida;

// Declare the RAM variable
reg [DATA_WIDTH-1:0] ram[2**ADDR_WIDTH-1:0];

initial
begin
	//$readmemb("memoriaDePrograma.txt", ram);
	//programa de teste
	/*ram[0] = 32'b0;
	ram[1] = {6'b111111, 5'd5, 5'd3, 5'd1, 11'b0};
	ram[2] = {6'b111111, 5'd6, 5'd4, 5'd2, 11'b0};
	ram[3] = {6'b111111, 5'd12, 5'd4, 5'd3, 11'b1};
	ram[4] = {6'b111111, 5'd7, 5'd6, 5'd5, 11'b0};
	ram[5] = {6'b111111, 5'd7, 5'd7, 5'd7, 11'b10000};
	ram[6] = {6'b111111, 5'd8, 5'd5, 5'd6, 11'd1};
	ram[7] = 32'b0;
	ram[8] = {6'b111111, 5'd1, 5'd3, 5'd0, 11'b11011};
	ram[9] = 32'b0;
	ram[10] = {6'b110001, 26'd50 };
	ram[50] = {6'b100000, 5'd7, 21'd12 };
	ram[51] = 32'b0;
	ram[52] = {6'b100100, 5'd13, 21'd12 };
	ram[53] = {6'b111111, 5'd14, 5'd13, 5'd3, 11'b0};
	ram[54] = {6'b000000, 5'd15, 5'd14, 16'd3};
	ram[55] = 32'b0;*/
ram[0] = 32'b11110000001000000000000000000000;
ram[1] = 32'b10000000001000000000000000001100;
ram[2] = 32'b11110000001000000000000000000000;
ram[3] = 32'b10000000001000000000000000010000;
ram[4] = 32'b10010000001000000000000000001100;
ram[5] = 32'b11111100010000010000000000010000;
ram[6] = 32'b10010000001000000000000000010000;
ram[7] = 32'b11111100011000010000000000010000;
ram[8] = 32'b11111100100000100001100000000000;
ram[9] = 32'b11110100100000000000000000000000;
ram[10] = 32'b11111100101000100001100000000001;
ram[11] = 32'b11110100101000000000000000000000;
ram[12] = 32'b11111100110000100001100000000010;
ram[13] = 32'b11110100110000000000000000000000;
ram[14] = 32'b11111100111000100001100000000011;
ram[15] = 32'b11110100111000000000000000000000;
ram[16] = 32'b11111101000000100001100000000100;
ram[17] = 32'b11110101000000000000000000000000;
ram[18] = 32'b11111101001000100001100000000101;
ram[19] = 32'b11110101001000000000000000000000;
ram[20] = 32'b11111101010000100001100000000110;
ram[21] = 32'b11110101010000000000000000000000;
ram[22] = 32'b11111101011000100001100000000111;
ram[23] = 32'b11110101011000000000000000000000;
ram[24] = 32'b11111101100000100001100000001000;
ram[25] = 32'b11110101100000000000000000000000;
ram[26] = 32'b11111101101000100001100000001001;
ram[27] = 32'b11110101101000000000000000000000;
ram[28] = 32'b11111101110000100001100000001010;
ram[29] = 32'b11110101110000000000000000000000;
ram[30] = 32'b11111101111000100001100000001011;
ram[31] = 32'b11110101111000000000000000000000;
ram[32] = 32'b11111110000000100001100000001100;
ram[33] = 32'b11110110000000000000000000000000;
ram[34] = 32'b11111110001000100001100000001101;
ram[35] = 32'b11110110001000000000000000000000;
ram[36] = 32'b11111110010000100001100000001110;
ram[37] = 32'b11110110010000000000000000000000;
ram[38] = 32'b11111110011000100001100000001111;
ram[39] = 32'b11110110011000000000000000000000;
ram[40] = 32'b11111110100000100000000000010000;
ram[41] = 32'b11110110100000000000000000000000;
ram[42] = 32'b11111110101000110000000000010001;
ram[43] = 32'b11110110101000000000000000000000;
ram[44] = 32'b11111100010000110000000000010010;
ram[45] = 32'b11111110110000000000000000010111;
ram[46] = 32'b11110110110000000000000000000000;
ram[47] = 32'b11111100010000110000000000010011;
ram[48] = 32'b11111110111000000000000000010111;
ram[49] = 32'b11110110111000000000000000000000;

end

always @ (negedge clk)
begin
	saida = ram[read_addr];
	
	if (EscMen)
		ram[write_addr] = data;
end

endmodule
